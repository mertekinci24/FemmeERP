using System;

namespace InventoryERP.Application.Common.Exceptions;

/// <summary>
/// R-358: Static error translator for humanizing database exceptions.
/// Stateless and thread-safe. Maps known SQLite errors to Turkish user-friendly messages.
/// </summary>
public static class ErrorTranslator
{
    /// <summary>
    /// Converts a raw exception into a user-friendly Turkish message.
    /// Recursively extracts the root cause and pattern-matches known error types.
    /// </summary>
    public static string Humanize(Exception ex)
    {
        // 1. Extract root cause (deepest InnerException)
        var root = GetRootException(ex);
        var msg = root.Message;
        
        // R-358/C: TRUST EXISTING FRIENDLY MESSAGES
        // If the message is generated by our own business logic (e.g., EnsureSkuIsUniqueAsync),
        // show it as-is instead of replacing with generic SQLite translation.
        if (msg.Contains("zaten kullanımda", StringComparison.OrdinalIgnoreCase) ||
            msg.Contains("already in use", StringComparison.OrdinalIgnoreCase) ||
            msg.Contains("zaten mevcut", StringComparison.OrdinalIgnoreCase) ||
            msg.Contains("zaten eklenmiş", StringComparison.OrdinalIgnoreCase) ||
            msg.Contains("bulunamadı", StringComparison.OrdinalIgnoreCase) ||
            msg.Contains("üretilemedi", StringComparison.OrdinalIgnoreCase))
        {
            return msg; // Trust the pre-localized business validation message
        }
        
        // 2. Pattern matching for known SQLite/EF Core errors
        // UNIQUE constraint violation
        if (msg.Contains("UNIQUE constraint", StringComparison.OrdinalIgnoreCase))
            return "Bu kayıt zaten mevcut (çift kayıt hatası).";
        
        // FOREIGN KEY constraint violation
        if (msg.Contains("FOREIGN KEY", StringComparison.OrdinalIgnoreCase))
            return "İlişkili kayıt bulunamadı veya silinmiş.";
        
        // CHECK constraint violation
        if (msg.Contains("CHECK constraint", StringComparison.OrdinalIgnoreCase))
            return "Girilen değer geçerli aralıkta değil.";
        
        // NOT NULL constraint violation
        if (msg.Contains("NOT NULL", StringComparison.OrdinalIgnoreCase) || 
            msg.Contains("cannot be null", StringComparison.OrdinalIgnoreCase))
            return "Zorunlu bir alan boş bırakılamaz.";
        
        // Table not found
        if (msg.Contains("no such table", StringComparison.OrdinalIgnoreCase))
            return "Veritabanı tablosu bulunamadı. Lütfen yönetici ile iletişime geçin.";
        
        // Column not found
        if (msg.Contains("no such column", StringComparison.OrdinalIgnoreCase))
            return "Veritabanı sütunu bulunamadı. Lütfen yönetici ile iletişime geçin.";
        
        // Database locked
        if (msg.Contains("database is locked", StringComparison.OrdinalIgnoreCase))
            return "Veritabanı şu anda başka bir işlem tarafından kullanılıyor. Lütfen tekrar deneyin.";
        
        // Concurrency/Version conflict
        if (msg.Contains("concurrency", StringComparison.OrdinalIgnoreCase) ||
            msg.Contains("modified or deleted", StringComparison.OrdinalIgnoreCase))
            return "Bu kayıt başka bir kullanıcı tarafından değiştirilmiş. Lütfen sayfayı yenileyip tekrar deneyin.";
        
        // R-360: REFLECTION-BASED CSV ERROR HANDLING (Zero Dependency)
        // Approved by Architecture Board to bypass layer restrictions.
        if (ex.GetType().FullName != null && ex.GetType().FullName.Contains("CsvHelper"))
        {
            try
            {
                var type = ex.GetType();
                
                // 1. Get Invalid Value (Text)
                var textVal = type.GetProperty("Text")?.GetValue(ex)?.ToString() ?? "Bilinmiyor";

                // 2. Get Column Name (MemberMapData -> Member -> Name)
                var memberName = "Bilinmiyor";
                var memberMapData = type.GetProperty("MemberMapData")?.GetValue(ex);
                if (memberMapData != null)
                {
                    var member = memberMapData.GetType().GetProperty("Member")?.GetValue(memberMapData);
                    if (member != null)
                        memberName = member.GetType().GetProperty("Name")?.GetValue(member)?.ToString() ?? "Bilinmiyor";
                }

                // 3. Get Row Number (Context -> Parser -> Row)
                var rowVal = "Bilinmiyor";
                var context = type.GetProperty("Context")?.GetValue(ex);
                if (context != null)
                {
                    var parser = context.GetType().GetProperty("Parser")?.GetValue(context);
                    if (parser != null)
                        rowVal = parser.GetType().GetProperty("Row")?.GetValue(parser)?.ToString() ?? "Bilinmiyor";
                }

                // 4. Return Friendly Message
                return $"CSV Dosyasında Veri Hatası!\n\n" +
                       $"Satır: {rowVal}\n" +
                       $"Sütun: {memberName}\n" +
                       $"Hatalı Veri: '{textVal}'\n\n" +
                       $"Çözüm: Excel dosyanızın {rowVal}. satırındaki '{memberName}' alanını kontrol edin.";
            }
            catch
            {
                // Fail-safe: If reflection fails (library update), fall back to generic message
                return $"CSV dosyası işlenirken bir format hatası oluştu. (Detay: {msg})";
            }
        }
            
        // 3. Fallback for unknown errors
        return "Beklenmedik bir hata oluştu.";
    }
    
    /// <summary>
    /// Recursively finds the innermost exception (root cause).
    /// </summary>
    private static Exception GetRootException(Exception ex)
    {
        while (ex.InnerException != null)
            ex = ex.InnerException;
        return ex;
    }
    
    /// <summary>
    /// Builds the full exception chain for logging purposes.
    /// </summary>
    public static string GetFullChain(Exception ex)
    {
        var messages = new System.Collections.Generic.List<string>();
        var current = ex;
        while (current != null)
        {
            messages.Add(current.Message);
            current = current.InnerException;
        }
        return string.Join(" --> ", messages);
    }
}
